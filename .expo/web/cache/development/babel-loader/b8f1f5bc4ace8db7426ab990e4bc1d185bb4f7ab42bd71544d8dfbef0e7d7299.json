{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nimport invariant from 'invariant';\nexport var CellRenderMask = function () {\n  function CellRenderMask(numCells) {\n    _classCallCheck(this, CellRenderMask);\n    invariant(numCells >= 0, 'CellRenderMask must contain a non-negative number os cells');\n    this._numCells = numCells;\n    if (numCells === 0) {\n      this._regions = [];\n    } else {\n      this._regions = [{\n        first: 0,\n        last: numCells - 1,\n        isSpacer: true\n      }];\n    }\n  }\n  _createClass(CellRenderMask, [{\n    key: \"enumerateRegions\",\n    value: function enumerateRegions() {\n      return this._regions;\n    }\n  }, {\n    key: \"addCells\",\n    value: function addCells(cells) {\n      var _this$_regions;\n      invariant(cells.first >= 0 && cells.first < this._numCells && cells.last >= -1 && cells.last < this._numCells && cells.last >= cells.first - 1, 'CellRenderMask.addCells called with invalid cell range');\n      if (cells.last < cells.first) {\n        return;\n      }\n      var _this$_findRegion = this._findRegion(cells.first),\n        _this$_findRegion2 = _slicedToArray(_this$_findRegion, 2),\n        firstIntersect = _this$_findRegion2[0],\n        firstIntersectIdx = _this$_findRegion2[1];\n      var _this$_findRegion3 = this._findRegion(cells.last),\n        _this$_findRegion4 = _slicedToArray(_this$_findRegion3, 2),\n        lastIntersect = _this$_findRegion4[0],\n        lastIntersectIdx = _this$_findRegion4[1];\n      if (firstIntersectIdx === lastIntersectIdx && !firstIntersect.isSpacer) {\n        return;\n      }\n      var newLeadRegion = [];\n      var newTailRegion = [];\n      var newMainRegion = _objectSpread(_objectSpread({}, cells), {}, {\n        isSpacer: false\n      });\n      if (firstIntersect.first < newMainRegion.first) {\n        if (firstIntersect.isSpacer) {\n          newLeadRegion.push({\n            first: firstIntersect.first,\n            last: newMainRegion.first - 1,\n            isSpacer: true\n          });\n        } else {\n          newMainRegion.first = firstIntersect.first;\n        }\n      }\n      if (lastIntersect.last > newMainRegion.last) {\n        if (lastIntersect.isSpacer) {\n          newTailRegion.push({\n            first: newMainRegion.last + 1,\n            last: lastIntersect.last,\n            isSpacer: true\n          });\n        } else {\n          newMainRegion.last = lastIntersect.last;\n        }\n      }\n      var replacementRegions = [].concat(newLeadRegion, [newMainRegion], newTailRegion);\n      var numRegionsToDelete = lastIntersectIdx - firstIntersectIdx + 1;\n      (_this$_regions = this._regions).splice.apply(_this$_regions, [firstIntersectIdx, numRegionsToDelete].concat(_toConsumableArray(replacementRegions)));\n    }\n  }, {\n    key: \"numCells\",\n    value: function numCells() {\n      return this._numCells;\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      return this._numCells === other._numCells && this._regions.length === other._regions.length && this._regions.every(function (region, i) {\n        return region.first === other._regions[i].first && region.last === other._regions[i].last && region.isSpacer === other._regions[i].isSpacer;\n      });\n    }\n  }, {\n    key: \"_findRegion\",\n    value: function _findRegion(cellIdx) {\n      var firstIdx = 0;\n      var lastIdx = this._regions.length - 1;\n      while (firstIdx <= lastIdx) {\n        var middleIdx = Math.floor((firstIdx + lastIdx) / 2);\n        var middleRegion = this._regions[middleIdx];\n        if (cellIdx >= middleRegion.first && cellIdx <= middleRegion.last) {\n          return [middleRegion, middleIdx];\n        } else if (cellIdx < middleRegion.first) {\n          lastIdx = middleIdx - 1;\n        } else if (cellIdx > middleRegion.last) {\n          firstIdx = middleIdx + 1;\n        }\n      }\n      invariant(false, `A region was not found containing cellIdx ${cellIdx}`);\n    }\n  }]);\n  return CellRenderMask;\n}();","map":{"version":3,"names":["invariant","CellRenderMask","numCells","_classCallCheck","_numCells","_regions","first","last","isSpacer","_createClass","key","value","enumerateRegions","addCells","cells","_this$_regions","_this$_findRegion","_findRegion","_this$_findRegion2","_slicedToArray","firstIntersect","firstIntersectIdx","_this$_findRegion3","_this$_findRegion4","lastIntersect","lastIntersectIdx","newLeadRegion","newTailRegion","newMainRegion","_objectSpread","push","replacementRegions","concat","numRegionsToDelete","splice","apply","_toConsumableArray","equals","other","length","every","region","i","cellIdx","firstIdx","lastIdx","middleIdx","Math","floor","middleRegion"],"sources":["C:/Users/arzug/Documents/GitHub/travel-brew/node_modules/@react-native/virtualized-lists/Lists/CellRenderMask.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow strict\n * @format\n */\n\nimport invariant from 'invariant';\n\nexport type CellRegion = {\n  first: number,\n  last: number,\n  isSpacer: boolean,\n};\n\nexport class CellRenderMask {\n  _numCells: number;\n  _regions: Array<CellRegion>;\n\n  constructor(numCells: number) {\n    invariant(\n      numCells >= 0,\n      'CellRenderMask must contain a non-negative number os cells',\n    );\n\n    this._numCells = numCells;\n\n    if (numCells === 0) {\n      this._regions = [];\n    } else {\n      this._regions = [\n        {\n          first: 0,\n          last: numCells - 1,\n          isSpacer: true,\n        },\n      ];\n    }\n  }\n\n  enumerateRegions(): $ReadOnlyArray<CellRegion> {\n    return this._regions;\n  }\n\n  addCells(cells: {first: number, last: number}): void {\n    invariant(\n      cells.first >= 0 &&\n        cells.first < this._numCells &&\n        cells.last >= -1 &&\n        cells.last < this._numCells &&\n        cells.last >= cells.first - 1,\n      'CellRenderMask.addCells called with invalid cell range',\n    );\n\n    // VirtualizedList uses inclusive ranges, where zero-count states are\n    // possible. E.g. [0, -1] for no cells, starting at 0.\n    if (cells.last < cells.first) {\n      return;\n    }\n\n    const [firstIntersect, firstIntersectIdx] = this._findRegion(cells.first);\n    const [lastIntersect, lastIntersectIdx] = this._findRegion(cells.last);\n\n    // Fast-path if the cells to add are already all present in the mask. We\n    // will otherwise need to do some mutation.\n    if (firstIntersectIdx === lastIntersectIdx && !firstIntersect.isSpacer) {\n      return;\n    }\n\n    // We need to replace the existing covered regions with 1-3 new regions\n    // depending whether we need to split spacers out of overlapping regions.\n    const newLeadRegion: Array<CellRegion> = [];\n    const newTailRegion: Array<CellRegion> = [];\n    const newMainRegion: CellRegion = {\n      ...cells,\n      isSpacer: false,\n    };\n\n    if (firstIntersect.first < newMainRegion.first) {\n      if (firstIntersect.isSpacer) {\n        newLeadRegion.push({\n          first: firstIntersect.first,\n          last: newMainRegion.first - 1,\n          isSpacer: true,\n        });\n      } else {\n        newMainRegion.first = firstIntersect.first;\n      }\n    }\n\n    if (lastIntersect.last > newMainRegion.last) {\n      if (lastIntersect.isSpacer) {\n        newTailRegion.push({\n          first: newMainRegion.last + 1,\n          last: lastIntersect.last,\n          isSpacer: true,\n        });\n      } else {\n        newMainRegion.last = lastIntersect.last;\n      }\n    }\n\n    const replacementRegions: Array<CellRegion> = [\n      ...newLeadRegion,\n      newMainRegion,\n      ...newTailRegion,\n    ];\n    const numRegionsToDelete = lastIntersectIdx - firstIntersectIdx + 1;\n    this._regions.splice(\n      firstIntersectIdx,\n      numRegionsToDelete,\n      ...replacementRegions,\n    );\n  }\n\n  numCells(): number {\n    return this._numCells;\n  }\n\n  equals(other: CellRenderMask): boolean {\n    return (\n      this._numCells === other._numCells &&\n      this._regions.length === other._regions.length &&\n      this._regions.every(\n        (region, i) =>\n          region.first === other._regions[i].first &&\n          region.last === other._regions[i].last &&\n          region.isSpacer === other._regions[i].isSpacer,\n      )\n    );\n  }\n\n  _findRegion(cellIdx: number): [CellRegion, number] {\n    let firstIdx = 0;\n    let lastIdx = this._regions.length - 1;\n\n    while (firstIdx <= lastIdx) {\n      const middleIdx = Math.floor((firstIdx + lastIdx) / 2);\n      const middleRegion = this._regions[middleIdx];\n\n      if (cellIdx >= middleRegion.first && cellIdx <= middleRegion.last) {\n        return [middleRegion, middleIdx];\n      } else if (cellIdx < middleRegion.first) {\n        lastIdx = middleIdx - 1;\n      } else if (cellIdx > middleRegion.last) {\n        firstIdx = middleIdx + 1;\n      }\n    }\n\n    invariant(false, `A region was not found containing cellIdx ${cellIdx}`);\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}